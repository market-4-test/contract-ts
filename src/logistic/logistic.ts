// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "logistic/logistic.proto" (package "logistic", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message logistic.Warehouse
 */
export interface Warehouse {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: string address = 2
     */
    address: string;
    /**
     * @generated from protobuf field: string name = 3
     */
    name: string;
    /**
     * @generated from protobuf field: bool is_active = 4
     */
    isActive: boolean;
}
/**
 * @generated from protobuf message logistic.WarehouseShort
 */
export interface WarehouseShort {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: string address = 2
     */
    address: string;
    /**
     * @generated from protobuf field: string name = 3
     */
    name: string;
}
/**
 * @generated from protobuf message logistic.GetWarehousesParams
 */
export interface GetWarehousesParams {
    /**
     * @generated from protobuf field: repeated int32 ids = 1
     */
    ids: number[];
}
/**
 * @generated from protobuf message logistic.GetWarehousesShortParams
 */
export interface GetWarehousesShortParams {
    /**
     * @generated from protobuf field: repeated int32 ids = 1
     */
    ids: number[];
}
/**
 * @generated from protobuf message logistic.GetWarehousesResponse
 */
export interface GetWarehousesResponse {
    /**
     * @generated from protobuf field: repeated logistic.Warehouse warehouses = 1
     */
    warehouses: Warehouse[];
}
/**
 * @generated from protobuf message logistic.GetWarehousesShortResponse
 */
export interface GetWarehousesShortResponse {
    /**
     * @generated from protobuf field: repeated logistic.WarehouseShort warehouses = 1
     */
    warehouses: WarehouseShort[];
}
/**
 * @generated from protobuf message logistic.GetWarehouseByIdParams
 */
export interface GetWarehouseByIdParams {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
}
/**
 * @generated from protobuf message logistic.CreateWarehouseParams
 */
export interface CreateWarehouseParams {
    /**
     * @generated from protobuf field: string address = 1
     */
    address: string;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
}
/**
 * @generated from protobuf message logistic.UpdateWarehouseParams
 */
export interface UpdateWarehouseParams {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: string address = 2
     */
    address: string;
    /**
     * @generated from protobuf field: string name = 3
     */
    name: string;
    /**
     * @generated from protobuf field: bool is_active = 4
     */
    isActive: boolean;
}
/**
 * @generated from protobuf message logistic.DeleteWarehousesParams
 */
export interface DeleteWarehousesParams {
    /**
     * @generated from protobuf field: repeated int32 id = 1
     */
    id: number[];
}
/**
 * @generated from protobuf message logistic.DeleteWarehousesResponse
 */
export interface DeleteWarehousesResponse {
    /**
     * @generated from protobuf field: repeated int32 attached_products = 1
     */
    attachedProducts: number[];
}
// @generated message type with reflection information, may provide speed optimized methods
class Warehouse$Type extends MessageType<Warehouse> {
    constructor() {
        super("logistic.Warehouse", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "is_active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Warehouse>): Warehouse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.address = "";
        message.name = "";
        message.isActive = false;
        if (value !== undefined)
            reflectionMergePartial<Warehouse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Warehouse): Warehouse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* string address */ 2:
                    message.address = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* bool is_active */ 4:
                    message.isActive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Warehouse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* string address = 2; */
        if (message.address !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.address);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* bool is_active = 4; */
        if (message.isActive !== false)
            writer.tag(4, WireType.Varint).bool(message.isActive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message logistic.Warehouse
 */
export const Warehouse = new Warehouse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WarehouseShort$Type extends MessageType<WarehouseShort> {
    constructor() {
        super("logistic.WarehouseShort", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WarehouseShort>): WarehouseShort {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.address = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<WarehouseShort>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WarehouseShort): WarehouseShort {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* string address */ 2:
                    message.address = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WarehouseShort, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* string address = 2; */
        if (message.address !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.address);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message logistic.WarehouseShort
 */
export const WarehouseShort = new WarehouseShort$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWarehousesParams$Type extends MessageType<GetWarehousesParams> {
    constructor() {
        super("logistic.GetWarehousesParams", [
            { no: 1, name: "ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetWarehousesParams>): GetWarehousesParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ids = [];
        if (value !== undefined)
            reflectionMergePartial<GetWarehousesParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWarehousesParams): GetWarehousesParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 ids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.ids.push(reader.int32());
                    else
                        message.ids.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWarehousesParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 ids = 1; */
        if (message.ids.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.ids.length; i++)
                writer.int32(message.ids[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message logistic.GetWarehousesParams
 */
export const GetWarehousesParams = new GetWarehousesParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWarehousesShortParams$Type extends MessageType<GetWarehousesShortParams> {
    constructor() {
        super("logistic.GetWarehousesShortParams", [
            { no: 1, name: "ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetWarehousesShortParams>): GetWarehousesShortParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ids = [];
        if (value !== undefined)
            reflectionMergePartial<GetWarehousesShortParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWarehousesShortParams): GetWarehousesShortParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 ids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.ids.push(reader.int32());
                    else
                        message.ids.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWarehousesShortParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 ids = 1; */
        if (message.ids.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.ids.length; i++)
                writer.int32(message.ids[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message logistic.GetWarehousesShortParams
 */
export const GetWarehousesShortParams = new GetWarehousesShortParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWarehousesResponse$Type extends MessageType<GetWarehousesResponse> {
    constructor() {
        super("logistic.GetWarehousesResponse", [
            { no: 1, name: "warehouses", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Warehouse }
        ]);
    }
    create(value?: PartialMessage<GetWarehousesResponse>): GetWarehousesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.warehouses = [];
        if (value !== undefined)
            reflectionMergePartial<GetWarehousesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWarehousesResponse): GetWarehousesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated logistic.Warehouse warehouses */ 1:
                    message.warehouses.push(Warehouse.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWarehousesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated logistic.Warehouse warehouses = 1; */
        for (let i = 0; i < message.warehouses.length; i++)
            Warehouse.internalBinaryWrite(message.warehouses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message logistic.GetWarehousesResponse
 */
export const GetWarehousesResponse = new GetWarehousesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWarehousesShortResponse$Type extends MessageType<GetWarehousesShortResponse> {
    constructor() {
        super("logistic.GetWarehousesShortResponse", [
            { no: 1, name: "warehouses", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => WarehouseShort }
        ]);
    }
    create(value?: PartialMessage<GetWarehousesShortResponse>): GetWarehousesShortResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.warehouses = [];
        if (value !== undefined)
            reflectionMergePartial<GetWarehousesShortResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWarehousesShortResponse): GetWarehousesShortResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated logistic.WarehouseShort warehouses */ 1:
                    message.warehouses.push(WarehouseShort.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWarehousesShortResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated logistic.WarehouseShort warehouses = 1; */
        for (let i = 0; i < message.warehouses.length; i++)
            WarehouseShort.internalBinaryWrite(message.warehouses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message logistic.GetWarehousesShortResponse
 */
export const GetWarehousesShortResponse = new GetWarehousesShortResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetWarehouseByIdParams$Type extends MessageType<GetWarehouseByIdParams> {
    constructor() {
        super("logistic.GetWarehouseByIdParams", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetWarehouseByIdParams>): GetWarehouseByIdParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        if (value !== undefined)
            reflectionMergePartial<GetWarehouseByIdParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetWarehouseByIdParams): GetWarehouseByIdParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetWarehouseByIdParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message logistic.GetWarehouseByIdParams
 */
export const GetWarehouseByIdParams = new GetWarehouseByIdParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateWarehouseParams$Type extends MessageType<CreateWarehouseParams> {
    constructor() {
        super("logistic.CreateWarehouseParams", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateWarehouseParams>): CreateWarehouseParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<CreateWarehouseParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateWarehouseParams): CreateWarehouseParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateWarehouseParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message logistic.CreateWarehouseParams
 */
export const CreateWarehouseParams = new CreateWarehouseParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateWarehouseParams$Type extends MessageType<UpdateWarehouseParams> {
    constructor() {
        super("logistic.UpdateWarehouseParams", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "is_active", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateWarehouseParams>): UpdateWarehouseParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.address = "";
        message.name = "";
        message.isActive = false;
        if (value !== undefined)
            reflectionMergePartial<UpdateWarehouseParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateWarehouseParams): UpdateWarehouseParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* string address */ 2:
                    message.address = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* bool is_active */ 4:
                    message.isActive = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateWarehouseParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* string address = 2; */
        if (message.address !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.address);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* bool is_active = 4; */
        if (message.isActive !== false)
            writer.tag(4, WireType.Varint).bool(message.isActive);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message logistic.UpdateWarehouseParams
 */
export const UpdateWarehouseParams = new UpdateWarehouseParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteWarehousesParams$Type extends MessageType<DeleteWarehousesParams> {
    constructor() {
        super("logistic.DeleteWarehousesParams", [
            { no: 1, name: "id", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteWarehousesParams>): DeleteWarehousesParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = [];
        if (value !== undefined)
            reflectionMergePartial<DeleteWarehousesParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteWarehousesParams): DeleteWarehousesParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 id */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.id.push(reader.int32());
                    else
                        message.id.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteWarehousesParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 id = 1; */
        if (message.id.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.id.length; i++)
                writer.int32(message.id[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message logistic.DeleteWarehousesParams
 */
export const DeleteWarehousesParams = new DeleteWarehousesParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteWarehousesResponse$Type extends MessageType<DeleteWarehousesResponse> {
    constructor() {
        super("logistic.DeleteWarehousesResponse", [
            { no: 1, name: "attached_products", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteWarehousesResponse>): DeleteWarehousesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.attachedProducts = [];
        if (value !== undefined)
            reflectionMergePartial<DeleteWarehousesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteWarehousesResponse): DeleteWarehousesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 attached_products */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.attachedProducts.push(reader.int32());
                    else
                        message.attachedProducts.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteWarehousesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 attached_products = 1; */
        if (message.attachedProducts.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.attachedProducts.length; i++)
                writer.int32(message.attachedProducts[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message logistic.DeleteWarehousesResponse
 */
export const DeleteWarehousesResponse = new DeleteWarehousesResponse$Type();
/**
 * @generated ServiceType for protobuf service logistic.Logistic
 */
export const Logistic = new ServiceType("logistic.Logistic", [
    { name: "GetWarehouses", options: {}, I: GetWarehousesParams, O: GetWarehousesResponse },
    { name: "GetWarehousesShort", options: {}, I: GetWarehousesShortParams, O: GetWarehousesShortResponse },
    { name: "GetWarehouseById", options: {}, I: GetWarehouseByIdParams, O: Warehouse },
    { name: "CreateWarehouse", options: {}, I: CreateWarehouseParams, O: Warehouse },
    { name: "UpdateWarehouse", options: {}, I: UpdateWarehouseParams, O: Warehouse },
    { name: "DeleteWarehouse", options: {}, I: DeleteWarehousesParams, O: DeleteWarehousesResponse }
]);
