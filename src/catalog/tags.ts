// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "catalog/tags.proto" (package "catalog", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { GetOffsetParams } from "../common/common";
import { PaginateMeta } from "../common/common";
import { GetPaginateParams } from "../common/common";
import { Timestamp } from "../google/protobuf/timestamp";
/**
 * @generated from protobuf message catalog.Tag
 */
export interface Tag {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 3
     */
    createdAt?: Timestamp;
    /**
     * @generated from protobuf field: google.protobuf.Timestamp updated_at = 4
     */
    updatedAt?: Timestamp;
}
/**
 * @generated from protobuf message catalog.TagShort
 */
export interface TagShort {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
}
/**
 * @generated from protobuf message catalog.UpsertTagParams
 */
export interface UpsertTagParams {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
}
/**
 * @generated from protobuf message catalog.CreateTagParams
 */
export interface CreateTagParams {
    /**
     * @generated from protobuf field: catalog.UpsertTagParams data = 1
     */
    data?: UpsertTagParams;
}
/**
 * @generated from protobuf message catalog.UpdateTagParams
 */
export interface UpdateTagParams {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: catalog.UpsertTagParams data = 2
     */
    data?: UpsertTagParams;
}
/**
 * @generated from protobuf message catalog.CheckAvailableTagNamesParams
 */
export interface CheckAvailableTagNamesParams {
    /**
     * @generated from protobuf field: repeated string name = 1
     */
    name: string[];
}
/**
 * @generated from protobuf message catalog.GetTagsPaginateParams
 */
export interface GetTagsPaginateParams {
    /**
     * @generated from protobuf field: common.GetPaginateParams params = 1
     */
    params?: GetPaginateParams;
}
/**
 * @generated from protobuf message catalog.GetTagsShortPaginateParams
 */
export interface GetTagsShortPaginateParams {
    /**
     * @generated from protobuf field: common.GetPaginateParams params = 1
     */
    params?: GetPaginateParams;
}
/**
 * @generated from protobuf message catalog.GetTagsPaginateResponse
 */
export interface GetTagsPaginateResponse {
    /**
     * @generated from protobuf field: repeated catalog.Tag list = 1
     */
    list: Tag[];
    /**
     * @generated from protobuf field: common.PaginateMeta meta = 2
     */
    meta?: PaginateMeta;
}
/**
 * @generated from protobuf message catalog.GetTagsShortPaginateResponse
 */
export interface GetTagsShortPaginateResponse {
    /**
     * @generated from protobuf field: repeated catalog.TagShort list = 1
     */
    list: TagShort[];
    /**
     * @generated from protobuf field: common.PaginateMeta meta = 2
     */
    meta?: PaginateMeta;
}
/**
 * @generated from protobuf message catalog.GetTagsOffsetParams
 */
export interface GetTagsOffsetParams {
    /**
     * @generated from protobuf field: common.GetOffsetParams params = 1
     */
    params?: GetOffsetParams;
}
/**
 * @generated from protobuf message catalog.GetTagsShortOffsetParams
 */
export interface GetTagsShortOffsetParams {
    /**
     * @generated from protobuf field: common.GetOffsetParams params = 1
     */
    params?: GetOffsetParams;
}
/**
 * @generated from protobuf message catalog.GetTagsOffsetResponse
 */
export interface GetTagsOffsetResponse {
    /**
     * @generated from protobuf field: repeated catalog.Tag list = 1
     */
    list: Tag[];
}
/**
 * @generated from protobuf message catalog.GetTagsShortOffsetResponse
 */
export interface GetTagsShortOffsetResponse {
    /**
     * @generated from protobuf field: repeated catalog.TagShort list = 1
     */
    list: TagShort[];
}
/**
 * @generated from protobuf message catalog.GetTagByIdParams
 */
export interface GetTagByIdParams {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
}
/**
 * @generated from protobuf message catalog.StatusTag
 */
export interface StatusTag {
    /**
     * @generated from protobuf field: int32 id = 1
     */
    id: number;
    /**
     * @generated from protobuf field: bool status = 2
     */
    status: boolean;
}
/**
 * @generated from protobuf message catalog.DeleteTagsParams
 */
export interface DeleteTagsParams {
    /**
     * @generated from protobuf field: repeated int32 ids = 1
     */
    ids: number[];
}
/**
 * @generated from protobuf message catalog.DeleteTagsResponse
 */
export interface DeleteTagsResponse {
    /**
     * @generated from protobuf field: repeated catalog.StatusTag list = 1
     */
    list: StatusTag[];
}
/**
 * @generated from protobuf message catalog.CheckAvailableTagNamesResponse
 */
export interface CheckAvailableTagNamesResponse {
    /**
     * @generated from protobuf field: repeated bool list = 1
     */
    list: boolean[];
}
// @generated message type with reflection information, may provide speed optimized methods
class Tag$Type extends MessageType<Tag> {
    constructor() {
        super("catalog.Tag", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "created_at", kind: "message", T: () => Timestamp },
            { no: 4, name: "updated_at", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Tag>): Tag {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<Tag>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Tag): Tag {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* google.protobuf.Timestamp created_at */ 3:
                    message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
                    break;
                case /* google.protobuf.Timestamp updated_at */ 4:
                    message.updatedAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updatedAt);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Tag, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* google.protobuf.Timestamp created_at = 3; */
        if (message.createdAt)
            Timestamp.internalBinaryWrite(message.createdAt, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp updated_at = 4; */
        if (message.updatedAt)
            Timestamp.internalBinaryWrite(message.updatedAt, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.Tag
 */
export const Tag = new Tag$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TagShort$Type extends MessageType<TagShort> {
    constructor() {
        super("catalog.TagShort", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TagShort>): TagShort {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<TagShort>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TagShort): TagShort {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TagShort, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.TagShort
 */
export const TagShort = new TagShort$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpsertTagParams$Type extends MessageType<UpsertTagParams> {
    constructor() {
        super("catalog.UpsertTagParams", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpsertTagParams>): UpsertTagParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        if (value !== undefined)
            reflectionMergePartial<UpsertTagParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpsertTagParams): UpsertTagParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpsertTagParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.UpsertTagParams
 */
export const UpsertTagParams = new UpsertTagParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateTagParams$Type extends MessageType<CreateTagParams> {
    constructor() {
        super("catalog.CreateTagParams", [
            { no: 1, name: "data", kind: "message", T: () => UpsertTagParams }
        ]);
    }
    create(value?: PartialMessage<CreateTagParams>): CreateTagParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateTagParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateTagParams): CreateTagParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* catalog.UpsertTagParams data */ 1:
                    message.data = UpsertTagParams.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateTagParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* catalog.UpsertTagParams data = 1; */
        if (message.data)
            UpsertTagParams.internalBinaryWrite(message.data, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.CreateTagParams
 */
export const CreateTagParams = new CreateTagParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateTagParams$Type extends MessageType<UpdateTagParams> {
    constructor() {
        super("catalog.UpdateTagParams", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "data", kind: "message", T: () => UpsertTagParams }
        ]);
    }
    create(value?: PartialMessage<UpdateTagParams>): UpdateTagParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        if (value !== undefined)
            reflectionMergePartial<UpdateTagParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateTagParams): UpdateTagParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* catalog.UpsertTagParams data */ 2:
                    message.data = UpsertTagParams.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateTagParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* catalog.UpsertTagParams data = 2; */
        if (message.data)
            UpsertTagParams.internalBinaryWrite(message.data, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.UpdateTagParams
 */
export const UpdateTagParams = new UpdateTagParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckAvailableTagNamesParams$Type extends MessageType<CheckAvailableTagNamesParams> {
    constructor() {
        super("catalog.CheckAvailableTagNamesParams", [
            { no: 1, name: "name", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CheckAvailableTagNamesParams>): CheckAvailableTagNamesParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = [];
        if (value !== undefined)
            reflectionMergePartial<CheckAvailableTagNamesParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckAvailableTagNamesParams): CheckAvailableTagNamesParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string name */ 1:
                    message.name.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckAvailableTagNamesParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string name = 1; */
        for (let i = 0; i < message.name.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.name[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.CheckAvailableTagNamesParams
 */
export const CheckAvailableTagNamesParams = new CheckAvailableTagNamesParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTagsPaginateParams$Type extends MessageType<GetTagsPaginateParams> {
    constructor() {
        super("catalog.GetTagsPaginateParams", [
            { no: 1, name: "params", kind: "message", T: () => GetPaginateParams }
        ]);
    }
    create(value?: PartialMessage<GetTagsPaginateParams>): GetTagsPaginateParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetTagsPaginateParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTagsPaginateParams): GetTagsPaginateParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* common.GetPaginateParams params */ 1:
                    message.params = GetPaginateParams.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTagsPaginateParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* common.GetPaginateParams params = 1; */
        if (message.params)
            GetPaginateParams.internalBinaryWrite(message.params, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.GetTagsPaginateParams
 */
export const GetTagsPaginateParams = new GetTagsPaginateParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTagsShortPaginateParams$Type extends MessageType<GetTagsShortPaginateParams> {
    constructor() {
        super("catalog.GetTagsShortPaginateParams", [
            { no: 1, name: "params", kind: "message", T: () => GetPaginateParams }
        ]);
    }
    create(value?: PartialMessage<GetTagsShortPaginateParams>): GetTagsShortPaginateParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetTagsShortPaginateParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTagsShortPaginateParams): GetTagsShortPaginateParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* common.GetPaginateParams params */ 1:
                    message.params = GetPaginateParams.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTagsShortPaginateParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* common.GetPaginateParams params = 1; */
        if (message.params)
            GetPaginateParams.internalBinaryWrite(message.params, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.GetTagsShortPaginateParams
 */
export const GetTagsShortPaginateParams = new GetTagsShortPaginateParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTagsPaginateResponse$Type extends MessageType<GetTagsPaginateResponse> {
    constructor() {
        super("catalog.GetTagsPaginateResponse", [
            { no: 1, name: "list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Tag },
            { no: 2, name: "meta", kind: "message", T: () => PaginateMeta }
        ]);
    }
    create(value?: PartialMessage<GetTagsPaginateResponse>): GetTagsPaginateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.list = [];
        if (value !== undefined)
            reflectionMergePartial<GetTagsPaginateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTagsPaginateResponse): GetTagsPaginateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated catalog.Tag list */ 1:
                    message.list.push(Tag.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* common.PaginateMeta meta */ 2:
                    message.meta = PaginateMeta.internalBinaryRead(reader, reader.uint32(), options, message.meta);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTagsPaginateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated catalog.Tag list = 1; */
        for (let i = 0; i < message.list.length; i++)
            Tag.internalBinaryWrite(message.list[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* common.PaginateMeta meta = 2; */
        if (message.meta)
            PaginateMeta.internalBinaryWrite(message.meta, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.GetTagsPaginateResponse
 */
export const GetTagsPaginateResponse = new GetTagsPaginateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTagsShortPaginateResponse$Type extends MessageType<GetTagsShortPaginateResponse> {
    constructor() {
        super("catalog.GetTagsShortPaginateResponse", [
            { no: 1, name: "list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TagShort },
            { no: 2, name: "meta", kind: "message", T: () => PaginateMeta }
        ]);
    }
    create(value?: PartialMessage<GetTagsShortPaginateResponse>): GetTagsShortPaginateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.list = [];
        if (value !== undefined)
            reflectionMergePartial<GetTagsShortPaginateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTagsShortPaginateResponse): GetTagsShortPaginateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated catalog.TagShort list */ 1:
                    message.list.push(TagShort.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* common.PaginateMeta meta */ 2:
                    message.meta = PaginateMeta.internalBinaryRead(reader, reader.uint32(), options, message.meta);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTagsShortPaginateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated catalog.TagShort list = 1; */
        for (let i = 0; i < message.list.length; i++)
            TagShort.internalBinaryWrite(message.list[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* common.PaginateMeta meta = 2; */
        if (message.meta)
            PaginateMeta.internalBinaryWrite(message.meta, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.GetTagsShortPaginateResponse
 */
export const GetTagsShortPaginateResponse = new GetTagsShortPaginateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTagsOffsetParams$Type extends MessageType<GetTagsOffsetParams> {
    constructor() {
        super("catalog.GetTagsOffsetParams", [
            { no: 1, name: "params", kind: "message", T: () => GetOffsetParams }
        ]);
    }
    create(value?: PartialMessage<GetTagsOffsetParams>): GetTagsOffsetParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetTagsOffsetParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTagsOffsetParams): GetTagsOffsetParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* common.GetOffsetParams params */ 1:
                    message.params = GetOffsetParams.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTagsOffsetParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* common.GetOffsetParams params = 1; */
        if (message.params)
            GetOffsetParams.internalBinaryWrite(message.params, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.GetTagsOffsetParams
 */
export const GetTagsOffsetParams = new GetTagsOffsetParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTagsShortOffsetParams$Type extends MessageType<GetTagsShortOffsetParams> {
    constructor() {
        super("catalog.GetTagsShortOffsetParams", [
            { no: 1, name: "params", kind: "message", T: () => GetOffsetParams }
        ]);
    }
    create(value?: PartialMessage<GetTagsShortOffsetParams>): GetTagsShortOffsetParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetTagsShortOffsetParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTagsShortOffsetParams): GetTagsShortOffsetParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* common.GetOffsetParams params */ 1:
                    message.params = GetOffsetParams.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTagsShortOffsetParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* common.GetOffsetParams params = 1; */
        if (message.params)
            GetOffsetParams.internalBinaryWrite(message.params, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.GetTagsShortOffsetParams
 */
export const GetTagsShortOffsetParams = new GetTagsShortOffsetParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTagsOffsetResponse$Type extends MessageType<GetTagsOffsetResponse> {
    constructor() {
        super("catalog.GetTagsOffsetResponse", [
            { no: 1, name: "list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Tag }
        ]);
    }
    create(value?: PartialMessage<GetTagsOffsetResponse>): GetTagsOffsetResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.list = [];
        if (value !== undefined)
            reflectionMergePartial<GetTagsOffsetResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTagsOffsetResponse): GetTagsOffsetResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated catalog.Tag list */ 1:
                    message.list.push(Tag.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTagsOffsetResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated catalog.Tag list = 1; */
        for (let i = 0; i < message.list.length; i++)
            Tag.internalBinaryWrite(message.list[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.GetTagsOffsetResponse
 */
export const GetTagsOffsetResponse = new GetTagsOffsetResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTagsShortOffsetResponse$Type extends MessageType<GetTagsShortOffsetResponse> {
    constructor() {
        super("catalog.GetTagsShortOffsetResponse", [
            { no: 1, name: "list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TagShort }
        ]);
    }
    create(value?: PartialMessage<GetTagsShortOffsetResponse>): GetTagsShortOffsetResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.list = [];
        if (value !== undefined)
            reflectionMergePartial<GetTagsShortOffsetResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTagsShortOffsetResponse): GetTagsShortOffsetResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated catalog.TagShort list */ 1:
                    message.list.push(TagShort.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTagsShortOffsetResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated catalog.TagShort list = 1; */
        for (let i = 0; i < message.list.length; i++)
            TagShort.internalBinaryWrite(message.list[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.GetTagsShortOffsetResponse
 */
export const GetTagsShortOffsetResponse = new GetTagsShortOffsetResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetTagByIdParams$Type extends MessageType<GetTagByIdParams> {
    constructor() {
        super("catalog.GetTagByIdParams", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetTagByIdParams>): GetTagByIdParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        if (value !== undefined)
            reflectionMergePartial<GetTagByIdParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetTagByIdParams): GetTagByIdParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetTagByIdParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.GetTagByIdParams
 */
export const GetTagByIdParams = new GetTagByIdParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StatusTag$Type extends MessageType<StatusTag> {
    constructor() {
        super("catalog.StatusTag", [
            { no: 1, name: "id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "status", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<StatusTag>): StatusTag {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = 0;
        message.status = false;
        if (value !== undefined)
            reflectionMergePartial<StatusTag>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StatusTag): StatusTag {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* bool status */ 2:
                    message.status = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StatusTag, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 id = 1; */
        if (message.id !== 0)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* bool status = 2; */
        if (message.status !== false)
            writer.tag(2, WireType.Varint).bool(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.StatusTag
 */
export const StatusTag = new StatusTag$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteTagsParams$Type extends MessageType<DeleteTagsParams> {
    constructor() {
        super("catalog.DeleteTagsParams", [
            { no: 1, name: "ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteTagsParams>): DeleteTagsParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.ids = [];
        if (value !== undefined)
            reflectionMergePartial<DeleteTagsParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteTagsParams): DeleteTagsParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 ids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.ids.push(reader.int32());
                    else
                        message.ids.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteTagsParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 ids = 1; */
        if (message.ids.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.ids.length; i++)
                writer.int32(message.ids[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.DeleteTagsParams
 */
export const DeleteTagsParams = new DeleteTagsParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteTagsResponse$Type extends MessageType<DeleteTagsResponse> {
    constructor() {
        super("catalog.DeleteTagsResponse", [
            { no: 1, name: "list", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => StatusTag }
        ]);
    }
    create(value?: PartialMessage<DeleteTagsResponse>): DeleteTagsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.list = [];
        if (value !== undefined)
            reflectionMergePartial<DeleteTagsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteTagsResponse): DeleteTagsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated catalog.StatusTag list */ 1:
                    message.list.push(StatusTag.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteTagsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated catalog.StatusTag list = 1; */
        for (let i = 0; i < message.list.length; i++)
            StatusTag.internalBinaryWrite(message.list[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.DeleteTagsResponse
 */
export const DeleteTagsResponse = new DeleteTagsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckAvailableTagNamesResponse$Type extends MessageType<CheckAvailableTagNamesResponse> {
    constructor() {
        super("catalog.CheckAvailableTagNamesResponse", [
            { no: 1, name: "list", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CheckAvailableTagNamesResponse>): CheckAvailableTagNamesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.list = [];
        if (value !== undefined)
            reflectionMergePartial<CheckAvailableTagNamesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckAvailableTagNamesResponse): CheckAvailableTagNamesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bool list */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.list.push(reader.bool());
                    else
                        message.list.push(reader.bool());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckAvailableTagNamesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bool list = 1; */
        if (message.list.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.list.length; i++)
                writer.bool(message.list[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.CheckAvailableTagNamesResponse
 */
export const CheckAvailableTagNamesResponse = new CheckAvailableTagNamesResponse$Type();
