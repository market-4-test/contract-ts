// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "catalog/products.proto" (package "catalog", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { PaginateMeta } from "../common/common";
import { GetOffsetParams } from "../common/common";
import { GetPaginateParams } from "../common/common";
/**
 * @generated from protobuf message catalog.Stock
 */
export interface Stock {
    /**
     * @generated from protobuf field: int32 warehouse_id = 1
     */
    warehouseId: number;
    /**
     * @generated from protobuf field: int32 count = 2
     */
    count: number; // -1 || > 0
}
/**
 * @generated from protobuf message catalog.ProductImage
 */
export interface ProductImage {
    /**
     * @generated from protobuf field: bytes uuid = 1
     */
    uuid: Uint8Array;
    /**
     * @generated from protobuf field: int32 sort_order = 2
     */
    sortOrder: number;
}
/**
 * @generated from protobuf message catalog.ProductMeta
 */
export interface ProductMeta {
    /**
     * @generated from protobuf field: bytes uuid = 1
     */
    uuid: Uint8Array;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: string slug = 3
     */
    slug: string;
    /**
     * @generated from protobuf field: string description = 4
     */
    description: string;
    /**
     * @generated from protobuf field: uint32 price = 5
     */
    price: number;
    /**
     * @generated from protobuf field: optional int32 brand_id = 6
     */
    brandId?: number;
}
/**
 * @generated from protobuf message catalog.Product
 */
export interface Product {
    /**
     * @generated from protobuf field: catalog.ProductMeta meta = 1
     */
    meta?: ProductMeta;
    /**
     * @generated from protobuf field: repeated catalog.ProductImage images = 2
     */
    images: ProductImage[];
    /**
     * @generated from protobuf field: repeated catalog.Stock stocks = 3
     */
    stocks: Stock[];
}
/**
 * @generated from protobuf message catalog.ProductShort
 */
export interface ProductShort {
    /**
     * @generated from protobuf field: catalog.ProductMeta meta = 1
     */
    meta?: ProductMeta;
    /**
     * @generated from protobuf field: catalog.ProductImage images = 2
     */
    images?: ProductImage;
}
/**
 * @generated from protobuf message catalog.GetProductsMeta
 */
export interface GetProductsMeta {
    /**
     * @generated from protobuf field: optional catalog.ProductStatus status = 1
     */
    status?: ProductStatus;
    /**
     * @generated from protobuf field: optional string query = 2
     */
    query?: string;
    /**
     * @generated from protobuf field: repeated int32 category_ids = 3
     */
    categoryIds: number[];
    /**
     * @generated from protobuf field: repeated int32 brand_ids = 4
     */
    brandIds: number[];
    /**
     * @generated from protobuf field: repeated int32 tag_ids = 5
     */
    tagIds: number[];
}
/**
 * @generated from protobuf message catalog.GetProductsPaginateParams
 */
export interface GetProductsPaginateParams {
    /**
     * @generated from protobuf field: common.GetPaginateParams params = 1
     */
    params?: GetPaginateParams;
    /**
     * @generated from protobuf field: catalog.GetProductsMeta meta = 2
     */
    meta?: GetProductsMeta;
}
/**
 * @generated from protobuf message catalog.GetProductsShortPaginateParams
 */
export interface GetProductsShortPaginateParams {
    /**
     * @generated from protobuf field: common.GetPaginateParams params = 1
     */
    params?: GetPaginateParams;
    /**
     * @generated from protobuf field: catalog.GetProductsMeta meta = 2
     */
    meta?: GetProductsMeta;
}
/**
 * @generated from protobuf message catalog.GetProductsOffsetParams
 */
export interface GetProductsOffsetParams {
    /**
     * @generated from protobuf field: common.GetOffsetParams params = 1
     */
    params?: GetOffsetParams;
    /**
     * @generated from protobuf field: optional catalog.ProductStatus status = 2
     */
    status?: ProductStatus;
    /**
     * @generated from protobuf field: catalog.GetProductsMeta meta = 3
     */
    meta?: GetProductsMeta;
}
/**
 * @generated from protobuf message catalog.GetProductsShortOffsetParams
 */
export interface GetProductsShortOffsetParams {
    /**
     * @generated from protobuf field: common.GetOffsetParams params = 1
     */
    params?: GetOffsetParams;
    /**
     * @generated from protobuf field: catalog.GetProductsMeta meta = 2
     */
    meta?: GetProductsMeta;
}
/**
 * @generated from protobuf message catalog.GetProductsPaginateResponse
 */
export interface GetProductsPaginateResponse {
    /**
     * @generated from protobuf field: catalog.Product list = 1
     */
    list?: Product;
    /**
     * @generated from protobuf field: common.PaginateMeta meta = 2
     */
    meta?: PaginateMeta;
}
/**
 * @generated from protobuf message catalog.GetProductsShortPaginateResponse
 */
export interface GetProductsShortPaginateResponse {
    /**
     * @generated from protobuf field: catalog.ProductShort list = 1
     */
    list?: ProductShort;
    /**
     * @generated from protobuf field: common.PaginateMeta meta = 2
     */
    meta?: PaginateMeta;
}
/**
 * @generated from protobuf message catalog.GetProductsOffsetResponse
 */
export interface GetProductsOffsetResponse {
    /**
     * @generated from protobuf field: catalog.Product list = 1
     */
    list?: Product;
}
/**
 * @generated from protobuf message catalog.GetProductsShortOffsetResponse
 */
export interface GetProductsShortOffsetResponse {
    /**
     * @generated from protobuf field: catalog.ProductShort list = 1
     */
    list?: ProductShort;
}
/**
 * @generated from protobuf message catalog.GetProductsResponse
 */
export interface GetProductsResponse {
    /**
     * @generated from protobuf field: catalog.Product list = 1
     */
    list?: Product;
}
/**
 * @generated from protobuf message catalog.GetProductsShortResponse
 */
export interface GetProductsShortResponse {
    /**
     * @generated from protobuf field: catalog.ProductShort list = 1
     */
    list?: ProductShort;
}
/**
 * @generated from protobuf message catalog.GetProductsByUuidsParams
 */
export interface GetProductsByUuidsParams {
    /**
     * @generated from protobuf field: repeated bytes uuid = 1
     */
    uuid: Uint8Array[];
}
/**
 * @generated from protobuf message catalog.GetProductByUuidParams
 */
export interface GetProductByUuidParams {
    /**
     * @generated from protobuf field: bytes uuid = 1
     */
    uuid: Uint8Array;
}
/**
 * @generated from protobuf message catalog.UpsertProductMetaParams
 */
export interface UpsertProductMetaParams {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: string slug = 2
     */
    slug: string;
    /**
     * @generated from protobuf field: string description = 3
     */
    description: string;
    /**
     * @generated from protobuf field: uint32 price = 4
     */
    price: number;
    /**
     * @generated from protobuf field: optional int32 brand_id = 5
     */
    brandId?: number;
}
/**
 * @generated from protobuf message catalog.CreateProductParams
 */
export interface CreateProductParams {
    /**
     * @generated from protobuf field: catalog.UpsertProductMetaParams data = 1
     */
    data?: UpsertProductMetaParams;
}
/**
 * @generated from protobuf message catalog.UpdateProductMetaParams
 */
export interface UpdateProductMetaParams {
    /**
     * @generated from protobuf field: bytes uuid = 1
     */
    uuid: Uint8Array;
    /**
     * @generated from protobuf field: catalog.UpsertProductMetaParams data = 2
     */
    data?: UpsertProductMetaParams;
}
/**
 * @generated from protobuf message catalog.UpdateProductStatusParams
 */
export interface UpdateProductStatusParams {
    /**
     * @generated from protobuf field: catalog.ProductStatus status = 1
     */
    status: ProductStatus;
    /**
     * @generated from protobuf field: repeated bytes uuids = 2
     */
    uuids: Uint8Array[];
}
/**
 * @generated from protobuf message catalog.UpdateProductPriceParams
 */
export interface UpdateProductPriceParams {
    /**
     * @generated from protobuf field: uint32 price = 1
     */
    price: number;
    /**
     * @generated from protobuf field: repeated bytes uuids = 2
     */
    uuids: Uint8Array[];
}
/**
 * @generated from protobuf message catalog.UpdateProductsStock
 */
export interface UpdateProductsStock {
    /**
     * @generated from protobuf field: int32 warehouse_id = 1
     */
    warehouseId: number;
    /**
     * @generated from protobuf field: int32 count = 2
     */
    count: number; // -1 - delete || >= 0 update
    /**
     * @generated from protobuf field: bytes product_uuid = 3
     */
    productUuid: Uint8Array;
}
/**
 * @generated from protobuf message catalog.UpdateProductsStocksParams
 */
export interface UpdateProductsStocksParams {
    /**
     * @generated from protobuf field: repeated catalog.UpdateProductsStock stocks = 1
     */
    stocks: UpdateProductsStock[];
}
/**
 * @generated from protobuf message catalog.UpdateProductsStockStatus
 */
export interface UpdateProductsStockStatus {
    /**
     * @generated from protobuf field: int32 warehouse_id = 1
     */
    warehouseId: number;
    /**
     * @generated from protobuf field: bytes product_uuid = 2
     */
    productUuid: Uint8Array;
    /**
     * @generated from protobuf field: bool status = 3
     */
    status: boolean;
}
/**
 * @generated from protobuf message catalog.UpdateProductsStocksResponse
 */
export interface UpdateProductsStocksResponse {
    /**
     * @generated from protobuf field: repeated catalog.UpdateProductsStockStatus statuses = 1
     */
    statuses: UpdateProductsStockStatus[];
}
/**
 * @generated from protobuf message catalog.UpdateProductsPrice
 */
export interface UpdateProductsPrice {
    /**
     * @generated from protobuf field: bytes product_uuid = 1
     */
    productUuid: Uint8Array;
    /**
     * @generated from protobuf field: int32 price = 2
     */
    price: number;
}
/**
 * @generated from protobuf message catalog.UpdateProductsPricesParams
 */
export interface UpdateProductsPricesParams {
    /**
     * @generated from protobuf field: repeated catalog.UpdateProductsStock stocks = 1
     */
    stocks: UpdateProductsStock[];
}
/**
 * @generated from protobuf message catalog.UpdateProductsPriceStatus
 */
export interface UpdateProductsPriceStatus {
    /**
     * @generated from protobuf field: bytes product_uuid = 2
     */
    productUuid: Uint8Array;
    /**
     * @generated from protobuf field: bool status = 3
     */
    status: boolean;
}
/**
 * @generated from protobuf message catalog.UpdateProductsPricesResponse
 */
export interface UpdateProductsPricesResponse {
    /**
     * @generated from protobuf field: repeated catalog.UpdateProductsPriceStatus statuses = 1
     */
    statuses: UpdateProductsPriceStatus[];
}
/**
 * @generated from protobuf message catalog.CheckProductAvailableSlugParams
 */
export interface CheckProductAvailableSlugParams {
    /**
     * @generated from protobuf field: string slug = 1
     */
    slug: string;
}
/**
 * @generated from protobuf message catalog.ToggleAttachProductsToCategories
 */
export interface ToggleAttachProductsToCategories {
    /**
     * @generated from protobuf field: repeated bytes product_uuids = 1
     */
    productUuids: Uint8Array[];
    /**
     * @generated from protobuf field: repeated bytes category_ids = 2
     */
    categoryIds: Uint8Array[];
}
/**
 * @generated from protobuf message catalog.ToggleAttachProductsToCategoryParams
 */
export interface ToggleAttachProductsToCategoryParams {
    /**
     * @generated from protobuf field: catalog.ToggleAttachProductsToCategories list = 1
     */
    list?: ToggleAttachProductsToCategories;
}
/**
 * @generated from protobuf message catalog.ToggleAttachProductsToBrands
 */
export interface ToggleAttachProductsToBrands {
    /**
     * @generated from protobuf field: repeated bytes product_uuids = 1
     */
    productUuids: Uint8Array[];
    /**
     * @generated from protobuf field: repeated int32 brand_ids = 2
     */
    brandIds: number[];
}
/**
 * @generated from protobuf message catalog.ToggleAttachProductsToBrandsParams
 */
export interface ToggleAttachProductsToBrandsParams {
    /**
     * @generated from protobuf field: catalog.ToggleAttachProductsToBrands list = 1
     */
    list?: ToggleAttachProductsToBrands;
}
/**
 * @generated from protobuf message catalog.ToggleAttachProductsToTags
 */
export interface ToggleAttachProductsToTags {
    /**
     * @generated from protobuf field: repeated bytes product_uuids = 1
     */
    productUuids: Uint8Array[];
    /**
     * @generated from protobuf field: repeated int32 tag_ids = 2
     */
    tagIds: number[];
}
/**
 * @generated from protobuf message catalog.ToggleAttachProductsToTagsParams
 */
export interface ToggleAttachProductsToTagsParams {
    /**
     * @generated from protobuf field: catalog.ToggleAttachProductsToBrands list = 1
     */
    list?: ToggleAttachProductsToBrands;
}
/**
 * @generated from protobuf enum catalog.ProductStatus
 */
export enum ProductStatus {
    /**
     * @generated from protobuf enum value: UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: DRAFT = 1;
     */
    DRAFT = 1,
    /**
     * @generated from protobuf enum value: PUBLISHED = 2;
     */
    PUBLISHED = 2,
    /**
     * deleted
     *
     * @generated from protobuf enum value: ARCHIVED = 3;
     */
    ARCHIVED = 3
}
// @generated message type with reflection information, may provide speed optimized methods
class Stock$Type extends MessageType<Stock> {
    constructor() {
        super("catalog.Stock", [
            { no: 1, name: "warehouse_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Stock>): Stock {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.warehouseId = 0;
        message.count = 0;
        if (value !== undefined)
            reflectionMergePartial<Stock>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Stock): Stock {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 warehouse_id */ 1:
                    message.warehouseId = reader.int32();
                    break;
                case /* int32 count */ 2:
                    message.count = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Stock, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 warehouse_id = 1; */
        if (message.warehouseId !== 0)
            writer.tag(1, WireType.Varint).int32(message.warehouseId);
        /* int32 count = 2; */
        if (message.count !== 0)
            writer.tag(2, WireType.Varint).int32(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.Stock
 */
export const Stock = new Stock$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProductImage$Type extends MessageType<ProductImage> {
    constructor() {
        super("catalog.ProductImage", [
            { no: 1, name: "uuid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "sort_order", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ProductImage>): ProductImage {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = new Uint8Array(0);
        message.sortOrder = 0;
        if (value !== undefined)
            reflectionMergePartial<ProductImage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProductImage): ProductImage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes uuid */ 1:
                    message.uuid = reader.bytes();
                    break;
                case /* int32 sort_order */ 2:
                    message.sortOrder = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProductImage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes uuid = 1; */
        if (message.uuid.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.uuid);
        /* int32 sort_order = 2; */
        if (message.sortOrder !== 0)
            writer.tag(2, WireType.Varint).int32(message.sortOrder);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.ProductImage
 */
export const ProductImage = new ProductImage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProductMeta$Type extends MessageType<ProductMeta> {
    constructor() {
        super("catalog.ProductMeta", [
            { no: 1, name: "uuid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "slug", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "price", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "brand_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ProductMeta>): ProductMeta {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = new Uint8Array(0);
        message.name = "";
        message.slug = "";
        message.description = "";
        message.price = 0;
        if (value !== undefined)
            reflectionMergePartial<ProductMeta>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProductMeta): ProductMeta {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes uuid */ 1:
                    message.uuid = reader.bytes();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string slug */ 3:
                    message.slug = reader.string();
                    break;
                case /* string description */ 4:
                    message.description = reader.string();
                    break;
                case /* uint32 price */ 5:
                    message.price = reader.uint32();
                    break;
                case /* optional int32 brand_id */ 6:
                    message.brandId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProductMeta, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes uuid = 1; */
        if (message.uuid.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.uuid);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string slug = 3; */
        if (message.slug !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.slug);
        /* string description = 4; */
        if (message.description !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.description);
        /* uint32 price = 5; */
        if (message.price !== 0)
            writer.tag(5, WireType.Varint).uint32(message.price);
        /* optional int32 brand_id = 6; */
        if (message.brandId !== undefined)
            writer.tag(6, WireType.Varint).int32(message.brandId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.ProductMeta
 */
export const ProductMeta = new ProductMeta$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Product$Type extends MessageType<Product> {
    constructor() {
        super("catalog.Product", [
            { no: 1, name: "meta", kind: "message", T: () => ProductMeta },
            { no: 2, name: "images", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ProductImage },
            { no: 3, name: "stocks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Stock }
        ]);
    }
    create(value?: PartialMessage<Product>): Product {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.images = [];
        message.stocks = [];
        if (value !== undefined)
            reflectionMergePartial<Product>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Product): Product {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* catalog.ProductMeta meta */ 1:
                    message.meta = ProductMeta.internalBinaryRead(reader, reader.uint32(), options, message.meta);
                    break;
                case /* repeated catalog.ProductImage images */ 2:
                    message.images.push(ProductImage.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated catalog.Stock stocks */ 3:
                    message.stocks.push(Stock.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Product, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* catalog.ProductMeta meta = 1; */
        if (message.meta)
            ProductMeta.internalBinaryWrite(message.meta, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated catalog.ProductImage images = 2; */
        for (let i = 0; i < message.images.length; i++)
            ProductImage.internalBinaryWrite(message.images[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated catalog.Stock stocks = 3; */
        for (let i = 0; i < message.stocks.length; i++)
            Stock.internalBinaryWrite(message.stocks[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.Product
 */
export const Product = new Product$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProductShort$Type extends MessageType<ProductShort> {
    constructor() {
        super("catalog.ProductShort", [
            { no: 1, name: "meta", kind: "message", T: () => ProductMeta },
            { no: 2, name: "images", kind: "message", T: () => ProductImage }
        ]);
    }
    create(value?: PartialMessage<ProductShort>): ProductShort {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ProductShort>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProductShort): ProductShort {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* catalog.ProductMeta meta */ 1:
                    message.meta = ProductMeta.internalBinaryRead(reader, reader.uint32(), options, message.meta);
                    break;
                case /* catalog.ProductImage images */ 2:
                    message.images = ProductImage.internalBinaryRead(reader, reader.uint32(), options, message.images);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProductShort, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* catalog.ProductMeta meta = 1; */
        if (message.meta)
            ProductMeta.internalBinaryWrite(message.meta, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* catalog.ProductImage images = 2; */
        if (message.images)
            ProductImage.internalBinaryWrite(message.images, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.ProductShort
 */
export const ProductShort = new ProductShort$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetProductsMeta$Type extends MessageType<GetProductsMeta> {
    constructor() {
        super("catalog.GetProductsMeta", [
            { no: 1, name: "status", kind: "enum", opt: true, T: () => ["catalog.ProductStatus", ProductStatus] },
            { no: 2, name: "query", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "category_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "brand_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "tag_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetProductsMeta>): GetProductsMeta {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.categoryIds = [];
        message.brandIds = [];
        message.tagIds = [];
        if (value !== undefined)
            reflectionMergePartial<GetProductsMeta>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetProductsMeta): GetProductsMeta {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional catalog.ProductStatus status */ 1:
                    message.status = reader.int32();
                    break;
                case /* optional string query */ 2:
                    message.query = reader.string();
                    break;
                case /* repeated int32 category_ids */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.categoryIds.push(reader.int32());
                    else
                        message.categoryIds.push(reader.int32());
                    break;
                case /* repeated int32 brand_ids */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.brandIds.push(reader.int32());
                    else
                        message.brandIds.push(reader.int32());
                    break;
                case /* repeated int32 tag_ids */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.tagIds.push(reader.int32());
                    else
                        message.tagIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetProductsMeta, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional catalog.ProductStatus status = 1; */
        if (message.status !== undefined)
            writer.tag(1, WireType.Varint).int32(message.status);
        /* optional string query = 2; */
        if (message.query !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.query);
        /* repeated int32 category_ids = 3; */
        if (message.categoryIds.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.categoryIds.length; i++)
                writer.int32(message.categoryIds[i]);
            writer.join();
        }
        /* repeated int32 brand_ids = 4; */
        if (message.brandIds.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.brandIds.length; i++)
                writer.int32(message.brandIds[i]);
            writer.join();
        }
        /* repeated int32 tag_ids = 5; */
        if (message.tagIds.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.tagIds.length; i++)
                writer.int32(message.tagIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.GetProductsMeta
 */
export const GetProductsMeta = new GetProductsMeta$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetProductsPaginateParams$Type extends MessageType<GetProductsPaginateParams> {
    constructor() {
        super("catalog.GetProductsPaginateParams", [
            { no: 1, name: "params", kind: "message", T: () => GetPaginateParams },
            { no: 2, name: "meta", kind: "message", T: () => GetProductsMeta }
        ]);
    }
    create(value?: PartialMessage<GetProductsPaginateParams>): GetProductsPaginateParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetProductsPaginateParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetProductsPaginateParams): GetProductsPaginateParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* common.GetPaginateParams params */ 1:
                    message.params = GetPaginateParams.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                case /* catalog.GetProductsMeta meta */ 2:
                    message.meta = GetProductsMeta.internalBinaryRead(reader, reader.uint32(), options, message.meta);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetProductsPaginateParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* common.GetPaginateParams params = 1; */
        if (message.params)
            GetPaginateParams.internalBinaryWrite(message.params, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* catalog.GetProductsMeta meta = 2; */
        if (message.meta)
            GetProductsMeta.internalBinaryWrite(message.meta, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.GetProductsPaginateParams
 */
export const GetProductsPaginateParams = new GetProductsPaginateParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetProductsShortPaginateParams$Type extends MessageType<GetProductsShortPaginateParams> {
    constructor() {
        super("catalog.GetProductsShortPaginateParams", [
            { no: 1, name: "params", kind: "message", T: () => GetPaginateParams },
            { no: 2, name: "meta", kind: "message", T: () => GetProductsMeta }
        ]);
    }
    create(value?: PartialMessage<GetProductsShortPaginateParams>): GetProductsShortPaginateParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetProductsShortPaginateParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetProductsShortPaginateParams): GetProductsShortPaginateParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* common.GetPaginateParams params */ 1:
                    message.params = GetPaginateParams.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                case /* catalog.GetProductsMeta meta */ 2:
                    message.meta = GetProductsMeta.internalBinaryRead(reader, reader.uint32(), options, message.meta);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetProductsShortPaginateParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* common.GetPaginateParams params = 1; */
        if (message.params)
            GetPaginateParams.internalBinaryWrite(message.params, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* catalog.GetProductsMeta meta = 2; */
        if (message.meta)
            GetProductsMeta.internalBinaryWrite(message.meta, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.GetProductsShortPaginateParams
 */
export const GetProductsShortPaginateParams = new GetProductsShortPaginateParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetProductsOffsetParams$Type extends MessageType<GetProductsOffsetParams> {
    constructor() {
        super("catalog.GetProductsOffsetParams", [
            { no: 1, name: "params", kind: "message", T: () => GetOffsetParams },
            { no: 2, name: "status", kind: "enum", opt: true, T: () => ["catalog.ProductStatus", ProductStatus] },
            { no: 3, name: "meta", kind: "message", T: () => GetProductsMeta }
        ]);
    }
    create(value?: PartialMessage<GetProductsOffsetParams>): GetProductsOffsetParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetProductsOffsetParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetProductsOffsetParams): GetProductsOffsetParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* common.GetOffsetParams params */ 1:
                    message.params = GetOffsetParams.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                case /* optional catalog.ProductStatus status */ 2:
                    message.status = reader.int32();
                    break;
                case /* catalog.GetProductsMeta meta */ 3:
                    message.meta = GetProductsMeta.internalBinaryRead(reader, reader.uint32(), options, message.meta);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetProductsOffsetParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* common.GetOffsetParams params = 1; */
        if (message.params)
            GetOffsetParams.internalBinaryWrite(message.params, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional catalog.ProductStatus status = 2; */
        if (message.status !== undefined)
            writer.tag(2, WireType.Varint).int32(message.status);
        /* catalog.GetProductsMeta meta = 3; */
        if (message.meta)
            GetProductsMeta.internalBinaryWrite(message.meta, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.GetProductsOffsetParams
 */
export const GetProductsOffsetParams = new GetProductsOffsetParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetProductsShortOffsetParams$Type extends MessageType<GetProductsShortOffsetParams> {
    constructor() {
        super("catalog.GetProductsShortOffsetParams", [
            { no: 1, name: "params", kind: "message", T: () => GetOffsetParams },
            { no: 2, name: "meta", kind: "message", T: () => GetProductsMeta }
        ]);
    }
    create(value?: PartialMessage<GetProductsShortOffsetParams>): GetProductsShortOffsetParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetProductsShortOffsetParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetProductsShortOffsetParams): GetProductsShortOffsetParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* common.GetOffsetParams params */ 1:
                    message.params = GetOffsetParams.internalBinaryRead(reader, reader.uint32(), options, message.params);
                    break;
                case /* catalog.GetProductsMeta meta */ 2:
                    message.meta = GetProductsMeta.internalBinaryRead(reader, reader.uint32(), options, message.meta);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetProductsShortOffsetParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* common.GetOffsetParams params = 1; */
        if (message.params)
            GetOffsetParams.internalBinaryWrite(message.params, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* catalog.GetProductsMeta meta = 2; */
        if (message.meta)
            GetProductsMeta.internalBinaryWrite(message.meta, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.GetProductsShortOffsetParams
 */
export const GetProductsShortOffsetParams = new GetProductsShortOffsetParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetProductsPaginateResponse$Type extends MessageType<GetProductsPaginateResponse> {
    constructor() {
        super("catalog.GetProductsPaginateResponse", [
            { no: 1, name: "list", kind: "message", T: () => Product },
            { no: 2, name: "meta", kind: "message", T: () => PaginateMeta }
        ]);
    }
    create(value?: PartialMessage<GetProductsPaginateResponse>): GetProductsPaginateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetProductsPaginateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetProductsPaginateResponse): GetProductsPaginateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* catalog.Product list */ 1:
                    message.list = Product.internalBinaryRead(reader, reader.uint32(), options, message.list);
                    break;
                case /* common.PaginateMeta meta */ 2:
                    message.meta = PaginateMeta.internalBinaryRead(reader, reader.uint32(), options, message.meta);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetProductsPaginateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* catalog.Product list = 1; */
        if (message.list)
            Product.internalBinaryWrite(message.list, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* common.PaginateMeta meta = 2; */
        if (message.meta)
            PaginateMeta.internalBinaryWrite(message.meta, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.GetProductsPaginateResponse
 */
export const GetProductsPaginateResponse = new GetProductsPaginateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetProductsShortPaginateResponse$Type extends MessageType<GetProductsShortPaginateResponse> {
    constructor() {
        super("catalog.GetProductsShortPaginateResponse", [
            { no: 1, name: "list", kind: "message", T: () => ProductShort },
            { no: 2, name: "meta", kind: "message", T: () => PaginateMeta }
        ]);
    }
    create(value?: PartialMessage<GetProductsShortPaginateResponse>): GetProductsShortPaginateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetProductsShortPaginateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetProductsShortPaginateResponse): GetProductsShortPaginateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* catalog.ProductShort list */ 1:
                    message.list = ProductShort.internalBinaryRead(reader, reader.uint32(), options, message.list);
                    break;
                case /* common.PaginateMeta meta */ 2:
                    message.meta = PaginateMeta.internalBinaryRead(reader, reader.uint32(), options, message.meta);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetProductsShortPaginateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* catalog.ProductShort list = 1; */
        if (message.list)
            ProductShort.internalBinaryWrite(message.list, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* common.PaginateMeta meta = 2; */
        if (message.meta)
            PaginateMeta.internalBinaryWrite(message.meta, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.GetProductsShortPaginateResponse
 */
export const GetProductsShortPaginateResponse = new GetProductsShortPaginateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetProductsOffsetResponse$Type extends MessageType<GetProductsOffsetResponse> {
    constructor() {
        super("catalog.GetProductsOffsetResponse", [
            { no: 1, name: "list", kind: "message", T: () => Product }
        ]);
    }
    create(value?: PartialMessage<GetProductsOffsetResponse>): GetProductsOffsetResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetProductsOffsetResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetProductsOffsetResponse): GetProductsOffsetResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* catalog.Product list */ 1:
                    message.list = Product.internalBinaryRead(reader, reader.uint32(), options, message.list);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetProductsOffsetResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* catalog.Product list = 1; */
        if (message.list)
            Product.internalBinaryWrite(message.list, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.GetProductsOffsetResponse
 */
export const GetProductsOffsetResponse = new GetProductsOffsetResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetProductsShortOffsetResponse$Type extends MessageType<GetProductsShortOffsetResponse> {
    constructor() {
        super("catalog.GetProductsShortOffsetResponse", [
            { no: 1, name: "list", kind: "message", T: () => ProductShort }
        ]);
    }
    create(value?: PartialMessage<GetProductsShortOffsetResponse>): GetProductsShortOffsetResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetProductsShortOffsetResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetProductsShortOffsetResponse): GetProductsShortOffsetResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* catalog.ProductShort list */ 1:
                    message.list = ProductShort.internalBinaryRead(reader, reader.uint32(), options, message.list);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetProductsShortOffsetResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* catalog.ProductShort list = 1; */
        if (message.list)
            ProductShort.internalBinaryWrite(message.list, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.GetProductsShortOffsetResponse
 */
export const GetProductsShortOffsetResponse = new GetProductsShortOffsetResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetProductsResponse$Type extends MessageType<GetProductsResponse> {
    constructor() {
        super("catalog.GetProductsResponse", [
            { no: 1, name: "list", kind: "message", T: () => Product }
        ]);
    }
    create(value?: PartialMessage<GetProductsResponse>): GetProductsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetProductsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetProductsResponse): GetProductsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* catalog.Product list */ 1:
                    message.list = Product.internalBinaryRead(reader, reader.uint32(), options, message.list);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetProductsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* catalog.Product list = 1; */
        if (message.list)
            Product.internalBinaryWrite(message.list, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.GetProductsResponse
 */
export const GetProductsResponse = new GetProductsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetProductsShortResponse$Type extends MessageType<GetProductsShortResponse> {
    constructor() {
        super("catalog.GetProductsShortResponse", [
            { no: 1, name: "list", kind: "message", T: () => ProductShort }
        ]);
    }
    create(value?: PartialMessage<GetProductsShortResponse>): GetProductsShortResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetProductsShortResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetProductsShortResponse): GetProductsShortResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* catalog.ProductShort list */ 1:
                    message.list = ProductShort.internalBinaryRead(reader, reader.uint32(), options, message.list);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetProductsShortResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* catalog.ProductShort list = 1; */
        if (message.list)
            ProductShort.internalBinaryWrite(message.list, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.GetProductsShortResponse
 */
export const GetProductsShortResponse = new GetProductsShortResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetProductsByUuidsParams$Type extends MessageType<GetProductsByUuidsParams> {
    constructor() {
        super("catalog.GetProductsByUuidsParams", [
            { no: 1, name: "uuid", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<GetProductsByUuidsParams>): GetProductsByUuidsParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = [];
        if (value !== undefined)
            reflectionMergePartial<GetProductsByUuidsParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetProductsByUuidsParams): GetProductsByUuidsParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes uuid */ 1:
                    message.uuid.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetProductsByUuidsParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes uuid = 1; */
        for (let i = 0; i < message.uuid.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.uuid[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.GetProductsByUuidsParams
 */
export const GetProductsByUuidsParams = new GetProductsByUuidsParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetProductByUuidParams$Type extends MessageType<GetProductByUuidParams> {
    constructor() {
        super("catalog.GetProductByUuidParams", [
            { no: 1, name: "uuid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<GetProductByUuidParams>): GetProductByUuidParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<GetProductByUuidParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetProductByUuidParams): GetProductByUuidParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes uuid */ 1:
                    message.uuid = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetProductByUuidParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes uuid = 1; */
        if (message.uuid.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.GetProductByUuidParams
 */
export const GetProductByUuidParams = new GetProductByUuidParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpsertProductMetaParams$Type extends MessageType<UpsertProductMetaParams> {
    constructor() {
        super("catalog.UpsertProductMetaParams", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "slug", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "price", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "brand_id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<UpsertProductMetaParams>): UpsertProductMetaParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.slug = "";
        message.description = "";
        message.price = 0;
        if (value !== undefined)
            reflectionMergePartial<UpsertProductMetaParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpsertProductMetaParams): UpsertProductMetaParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string slug */ 2:
                    message.slug = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* uint32 price */ 4:
                    message.price = reader.uint32();
                    break;
                case /* optional int32 brand_id */ 5:
                    message.brandId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpsertProductMetaParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string slug = 2; */
        if (message.slug !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.slug);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* uint32 price = 4; */
        if (message.price !== 0)
            writer.tag(4, WireType.Varint).uint32(message.price);
        /* optional int32 brand_id = 5; */
        if (message.brandId !== undefined)
            writer.tag(5, WireType.Varint).int32(message.brandId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.UpsertProductMetaParams
 */
export const UpsertProductMetaParams = new UpsertProductMetaParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateProductParams$Type extends MessageType<CreateProductParams> {
    constructor() {
        super("catalog.CreateProductParams", [
            { no: 1, name: "data", kind: "message", T: () => UpsertProductMetaParams }
        ]);
    }
    create(value?: PartialMessage<CreateProductParams>): CreateProductParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateProductParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateProductParams): CreateProductParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* catalog.UpsertProductMetaParams data */ 1:
                    message.data = UpsertProductMetaParams.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateProductParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* catalog.UpsertProductMetaParams data = 1; */
        if (message.data)
            UpsertProductMetaParams.internalBinaryWrite(message.data, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.CreateProductParams
 */
export const CreateProductParams = new CreateProductParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateProductMetaParams$Type extends MessageType<UpdateProductMetaParams> {
    constructor() {
        super("catalog.UpdateProductMetaParams", [
            { no: 1, name: "uuid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "data", kind: "message", T: () => UpsertProductMetaParams }
        ]);
    }
    create(value?: PartialMessage<UpdateProductMetaParams>): UpdateProductMetaParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<UpdateProductMetaParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateProductMetaParams): UpdateProductMetaParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes uuid */ 1:
                    message.uuid = reader.bytes();
                    break;
                case /* catalog.UpsertProductMetaParams data */ 2:
                    message.data = UpsertProductMetaParams.internalBinaryRead(reader, reader.uint32(), options, message.data);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateProductMetaParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes uuid = 1; */
        if (message.uuid.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.uuid);
        /* catalog.UpsertProductMetaParams data = 2; */
        if (message.data)
            UpsertProductMetaParams.internalBinaryWrite(message.data, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.UpdateProductMetaParams
 */
export const UpdateProductMetaParams = new UpdateProductMetaParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateProductStatusParams$Type extends MessageType<UpdateProductStatusParams> {
    constructor() {
        super("catalog.UpdateProductStatusParams", [
            { no: 1, name: "status", kind: "enum", T: () => ["catalog.ProductStatus", ProductStatus] },
            { no: 2, name: "uuids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateProductStatusParams>): UpdateProductStatusParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = 0;
        message.uuids = [];
        if (value !== undefined)
            reflectionMergePartial<UpdateProductStatusParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateProductStatusParams): UpdateProductStatusParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* catalog.ProductStatus status */ 1:
                    message.status = reader.int32();
                    break;
                case /* repeated bytes uuids */ 2:
                    message.uuids.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateProductStatusParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* catalog.ProductStatus status = 1; */
        if (message.status !== 0)
            writer.tag(1, WireType.Varint).int32(message.status);
        /* repeated bytes uuids = 2; */
        for (let i = 0; i < message.uuids.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.uuids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.UpdateProductStatusParams
 */
export const UpdateProductStatusParams = new UpdateProductStatusParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateProductPriceParams$Type extends MessageType<UpdateProductPriceParams> {
    constructor() {
        super("catalog.UpdateProductPriceParams", [
            { no: 1, name: "price", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "uuids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateProductPriceParams>): UpdateProductPriceParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.price = 0;
        message.uuids = [];
        if (value !== undefined)
            reflectionMergePartial<UpdateProductPriceParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateProductPriceParams): UpdateProductPriceParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 price */ 1:
                    message.price = reader.uint32();
                    break;
                case /* repeated bytes uuids */ 2:
                    message.uuids.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateProductPriceParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 price = 1; */
        if (message.price !== 0)
            writer.tag(1, WireType.Varint).uint32(message.price);
        /* repeated bytes uuids = 2; */
        for (let i = 0; i < message.uuids.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.uuids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.UpdateProductPriceParams
 */
export const UpdateProductPriceParams = new UpdateProductPriceParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateProductsStock$Type extends MessageType<UpdateProductsStock> {
    constructor() {
        super("catalog.UpdateProductsStock", [
            { no: 1, name: "warehouse_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "product_uuid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateProductsStock>): UpdateProductsStock {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.warehouseId = 0;
        message.count = 0;
        message.productUuid = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<UpdateProductsStock>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateProductsStock): UpdateProductsStock {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 warehouse_id */ 1:
                    message.warehouseId = reader.int32();
                    break;
                case /* int32 count */ 2:
                    message.count = reader.int32();
                    break;
                case /* bytes product_uuid */ 3:
                    message.productUuid = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateProductsStock, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 warehouse_id = 1; */
        if (message.warehouseId !== 0)
            writer.tag(1, WireType.Varint).int32(message.warehouseId);
        /* int32 count = 2; */
        if (message.count !== 0)
            writer.tag(2, WireType.Varint).int32(message.count);
        /* bytes product_uuid = 3; */
        if (message.productUuid.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.productUuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.UpdateProductsStock
 */
export const UpdateProductsStock = new UpdateProductsStock$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateProductsStocksParams$Type extends MessageType<UpdateProductsStocksParams> {
    constructor() {
        super("catalog.UpdateProductsStocksParams", [
            { no: 1, name: "stocks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UpdateProductsStock }
        ]);
    }
    create(value?: PartialMessage<UpdateProductsStocksParams>): UpdateProductsStocksParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stocks = [];
        if (value !== undefined)
            reflectionMergePartial<UpdateProductsStocksParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateProductsStocksParams): UpdateProductsStocksParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated catalog.UpdateProductsStock stocks */ 1:
                    message.stocks.push(UpdateProductsStock.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateProductsStocksParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated catalog.UpdateProductsStock stocks = 1; */
        for (let i = 0; i < message.stocks.length; i++)
            UpdateProductsStock.internalBinaryWrite(message.stocks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.UpdateProductsStocksParams
 */
export const UpdateProductsStocksParams = new UpdateProductsStocksParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateProductsStockStatus$Type extends MessageType<UpdateProductsStockStatus> {
    constructor() {
        super("catalog.UpdateProductsStockStatus", [
            { no: 1, name: "warehouse_id", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "product_uuid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "status", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateProductsStockStatus>): UpdateProductsStockStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.warehouseId = 0;
        message.productUuid = new Uint8Array(0);
        message.status = false;
        if (value !== undefined)
            reflectionMergePartial<UpdateProductsStockStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateProductsStockStatus): UpdateProductsStockStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 warehouse_id */ 1:
                    message.warehouseId = reader.int32();
                    break;
                case /* bytes product_uuid */ 2:
                    message.productUuid = reader.bytes();
                    break;
                case /* bool status */ 3:
                    message.status = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateProductsStockStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 warehouse_id = 1; */
        if (message.warehouseId !== 0)
            writer.tag(1, WireType.Varint).int32(message.warehouseId);
        /* bytes product_uuid = 2; */
        if (message.productUuid.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.productUuid);
        /* bool status = 3; */
        if (message.status !== false)
            writer.tag(3, WireType.Varint).bool(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.UpdateProductsStockStatus
 */
export const UpdateProductsStockStatus = new UpdateProductsStockStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateProductsStocksResponse$Type extends MessageType<UpdateProductsStocksResponse> {
    constructor() {
        super("catalog.UpdateProductsStocksResponse", [
            { no: 1, name: "statuses", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UpdateProductsStockStatus }
        ]);
    }
    create(value?: PartialMessage<UpdateProductsStocksResponse>): UpdateProductsStocksResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statuses = [];
        if (value !== undefined)
            reflectionMergePartial<UpdateProductsStocksResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateProductsStocksResponse): UpdateProductsStocksResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated catalog.UpdateProductsStockStatus statuses */ 1:
                    message.statuses.push(UpdateProductsStockStatus.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateProductsStocksResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated catalog.UpdateProductsStockStatus statuses = 1; */
        for (let i = 0; i < message.statuses.length; i++)
            UpdateProductsStockStatus.internalBinaryWrite(message.statuses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.UpdateProductsStocksResponse
 */
export const UpdateProductsStocksResponse = new UpdateProductsStocksResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateProductsPrice$Type extends MessageType<UpdateProductsPrice> {
    constructor() {
        super("catalog.UpdateProductsPrice", [
            { no: 1, name: "product_uuid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "price", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateProductsPrice>): UpdateProductsPrice {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.productUuid = new Uint8Array(0);
        message.price = 0;
        if (value !== undefined)
            reflectionMergePartial<UpdateProductsPrice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateProductsPrice): UpdateProductsPrice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes product_uuid */ 1:
                    message.productUuid = reader.bytes();
                    break;
                case /* int32 price */ 2:
                    message.price = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateProductsPrice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes product_uuid = 1; */
        if (message.productUuid.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.productUuid);
        /* int32 price = 2; */
        if (message.price !== 0)
            writer.tag(2, WireType.Varint).int32(message.price);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.UpdateProductsPrice
 */
export const UpdateProductsPrice = new UpdateProductsPrice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateProductsPricesParams$Type extends MessageType<UpdateProductsPricesParams> {
    constructor() {
        super("catalog.UpdateProductsPricesParams", [
            { no: 1, name: "stocks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UpdateProductsStock }
        ]);
    }
    create(value?: PartialMessage<UpdateProductsPricesParams>): UpdateProductsPricesParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.stocks = [];
        if (value !== undefined)
            reflectionMergePartial<UpdateProductsPricesParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateProductsPricesParams): UpdateProductsPricesParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated catalog.UpdateProductsStock stocks */ 1:
                    message.stocks.push(UpdateProductsStock.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateProductsPricesParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated catalog.UpdateProductsStock stocks = 1; */
        for (let i = 0; i < message.stocks.length; i++)
            UpdateProductsStock.internalBinaryWrite(message.stocks[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.UpdateProductsPricesParams
 */
export const UpdateProductsPricesParams = new UpdateProductsPricesParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateProductsPriceStatus$Type extends MessageType<UpdateProductsPriceStatus> {
    constructor() {
        super("catalog.UpdateProductsPriceStatus", [
            { no: 2, name: "product_uuid", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "status", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateProductsPriceStatus>): UpdateProductsPriceStatus {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.productUuid = new Uint8Array(0);
        message.status = false;
        if (value !== undefined)
            reflectionMergePartial<UpdateProductsPriceStatus>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateProductsPriceStatus): UpdateProductsPriceStatus {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes product_uuid */ 2:
                    message.productUuid = reader.bytes();
                    break;
                case /* bool status */ 3:
                    message.status = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateProductsPriceStatus, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes product_uuid = 2; */
        if (message.productUuid.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.productUuid);
        /* bool status = 3; */
        if (message.status !== false)
            writer.tag(3, WireType.Varint).bool(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.UpdateProductsPriceStatus
 */
export const UpdateProductsPriceStatus = new UpdateProductsPriceStatus$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateProductsPricesResponse$Type extends MessageType<UpdateProductsPricesResponse> {
    constructor() {
        super("catalog.UpdateProductsPricesResponse", [
            { no: 1, name: "statuses", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UpdateProductsPriceStatus }
        ]);
    }
    create(value?: PartialMessage<UpdateProductsPricesResponse>): UpdateProductsPricesResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statuses = [];
        if (value !== undefined)
            reflectionMergePartial<UpdateProductsPricesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateProductsPricesResponse): UpdateProductsPricesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated catalog.UpdateProductsPriceStatus statuses */ 1:
                    message.statuses.push(UpdateProductsPriceStatus.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateProductsPricesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated catalog.UpdateProductsPriceStatus statuses = 1; */
        for (let i = 0; i < message.statuses.length; i++)
            UpdateProductsPriceStatus.internalBinaryWrite(message.statuses[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.UpdateProductsPricesResponse
 */
export const UpdateProductsPricesResponse = new UpdateProductsPricesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CheckProductAvailableSlugParams$Type extends MessageType<CheckProductAvailableSlugParams> {
    constructor() {
        super("catalog.CheckProductAvailableSlugParams", [
            { no: 1, name: "slug", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CheckProductAvailableSlugParams>): CheckProductAvailableSlugParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.slug = "";
        if (value !== undefined)
            reflectionMergePartial<CheckProductAvailableSlugParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CheckProductAvailableSlugParams): CheckProductAvailableSlugParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string slug */ 1:
                    message.slug = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CheckProductAvailableSlugParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string slug = 1; */
        if (message.slug !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.slug);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.CheckProductAvailableSlugParams
 */
export const CheckProductAvailableSlugParams = new CheckProductAvailableSlugParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ToggleAttachProductsToCategories$Type extends MessageType<ToggleAttachProductsToCategories> {
    constructor() {
        super("catalog.ToggleAttachProductsToCategories", [
            { no: 1, name: "product_uuids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "category_ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ToggleAttachProductsToCategories>): ToggleAttachProductsToCategories {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.productUuids = [];
        message.categoryIds = [];
        if (value !== undefined)
            reflectionMergePartial<ToggleAttachProductsToCategories>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ToggleAttachProductsToCategories): ToggleAttachProductsToCategories {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes product_uuids */ 1:
                    message.productUuids.push(reader.bytes());
                    break;
                case /* repeated bytes category_ids */ 2:
                    message.categoryIds.push(reader.bytes());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ToggleAttachProductsToCategories, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes product_uuids = 1; */
        for (let i = 0; i < message.productUuids.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.productUuids[i]);
        /* repeated bytes category_ids = 2; */
        for (let i = 0; i < message.categoryIds.length; i++)
            writer.tag(2, WireType.LengthDelimited).bytes(message.categoryIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.ToggleAttachProductsToCategories
 */
export const ToggleAttachProductsToCategories = new ToggleAttachProductsToCategories$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ToggleAttachProductsToCategoryParams$Type extends MessageType<ToggleAttachProductsToCategoryParams> {
    constructor() {
        super("catalog.ToggleAttachProductsToCategoryParams", [
            { no: 1, name: "list", kind: "message", T: () => ToggleAttachProductsToCategories }
        ]);
    }
    create(value?: PartialMessage<ToggleAttachProductsToCategoryParams>): ToggleAttachProductsToCategoryParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ToggleAttachProductsToCategoryParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ToggleAttachProductsToCategoryParams): ToggleAttachProductsToCategoryParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* catalog.ToggleAttachProductsToCategories list */ 1:
                    message.list = ToggleAttachProductsToCategories.internalBinaryRead(reader, reader.uint32(), options, message.list);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ToggleAttachProductsToCategoryParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* catalog.ToggleAttachProductsToCategories list = 1; */
        if (message.list)
            ToggleAttachProductsToCategories.internalBinaryWrite(message.list, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.ToggleAttachProductsToCategoryParams
 */
export const ToggleAttachProductsToCategoryParams = new ToggleAttachProductsToCategoryParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ToggleAttachProductsToBrands$Type extends MessageType<ToggleAttachProductsToBrands> {
    constructor() {
        super("catalog.ToggleAttachProductsToBrands", [
            { no: 1, name: "product_uuids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "brand_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ToggleAttachProductsToBrands>): ToggleAttachProductsToBrands {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.productUuids = [];
        message.brandIds = [];
        if (value !== undefined)
            reflectionMergePartial<ToggleAttachProductsToBrands>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ToggleAttachProductsToBrands): ToggleAttachProductsToBrands {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes product_uuids */ 1:
                    message.productUuids.push(reader.bytes());
                    break;
                case /* repeated int32 brand_ids */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.brandIds.push(reader.int32());
                    else
                        message.brandIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ToggleAttachProductsToBrands, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes product_uuids = 1; */
        for (let i = 0; i < message.productUuids.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.productUuids[i]);
        /* repeated int32 brand_ids = 2; */
        if (message.brandIds.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.brandIds.length; i++)
                writer.int32(message.brandIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.ToggleAttachProductsToBrands
 */
export const ToggleAttachProductsToBrands = new ToggleAttachProductsToBrands$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ToggleAttachProductsToBrandsParams$Type extends MessageType<ToggleAttachProductsToBrandsParams> {
    constructor() {
        super("catalog.ToggleAttachProductsToBrandsParams", [
            { no: 1, name: "list", kind: "message", T: () => ToggleAttachProductsToBrands }
        ]);
    }
    create(value?: PartialMessage<ToggleAttachProductsToBrandsParams>): ToggleAttachProductsToBrandsParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ToggleAttachProductsToBrandsParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ToggleAttachProductsToBrandsParams): ToggleAttachProductsToBrandsParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* catalog.ToggleAttachProductsToBrands list */ 1:
                    message.list = ToggleAttachProductsToBrands.internalBinaryRead(reader, reader.uint32(), options, message.list);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ToggleAttachProductsToBrandsParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* catalog.ToggleAttachProductsToBrands list = 1; */
        if (message.list)
            ToggleAttachProductsToBrands.internalBinaryWrite(message.list, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.ToggleAttachProductsToBrandsParams
 */
export const ToggleAttachProductsToBrandsParams = new ToggleAttachProductsToBrandsParams$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ToggleAttachProductsToTags$Type extends MessageType<ToggleAttachProductsToTags> {
    constructor() {
        super("catalog.ToggleAttachProductsToTags", [
            { no: 1, name: "product_uuids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "tag_ids", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ToggleAttachProductsToTags>): ToggleAttachProductsToTags {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.productUuids = [];
        message.tagIds = [];
        if (value !== undefined)
            reflectionMergePartial<ToggleAttachProductsToTags>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ToggleAttachProductsToTags): ToggleAttachProductsToTags {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated bytes product_uuids */ 1:
                    message.productUuids.push(reader.bytes());
                    break;
                case /* repeated int32 tag_ids */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.tagIds.push(reader.int32());
                    else
                        message.tagIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ToggleAttachProductsToTags, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated bytes product_uuids = 1; */
        for (let i = 0; i < message.productUuids.length; i++)
            writer.tag(1, WireType.LengthDelimited).bytes(message.productUuids[i]);
        /* repeated int32 tag_ids = 2; */
        if (message.tagIds.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.tagIds.length; i++)
                writer.int32(message.tagIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.ToggleAttachProductsToTags
 */
export const ToggleAttachProductsToTags = new ToggleAttachProductsToTags$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ToggleAttachProductsToTagsParams$Type extends MessageType<ToggleAttachProductsToTagsParams> {
    constructor() {
        super("catalog.ToggleAttachProductsToTagsParams", [
            { no: 1, name: "list", kind: "message", T: () => ToggleAttachProductsToBrands }
        ]);
    }
    create(value?: PartialMessage<ToggleAttachProductsToTagsParams>): ToggleAttachProductsToTagsParams {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ToggleAttachProductsToTagsParams>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ToggleAttachProductsToTagsParams): ToggleAttachProductsToTagsParams {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* catalog.ToggleAttachProductsToBrands list */ 1:
                    message.list = ToggleAttachProductsToBrands.internalBinaryRead(reader, reader.uint32(), options, message.list);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ToggleAttachProductsToTagsParams, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* catalog.ToggleAttachProductsToBrands list = 1; */
        if (message.list)
            ToggleAttachProductsToBrands.internalBinaryWrite(message.list, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message catalog.ToggleAttachProductsToTagsParams
 */
export const ToggleAttachProductsToTagsParams = new ToggleAttachProductsToTagsParams$Type();
